//! Property-based tests for diff-gitignore-filter
//!
//! Uses proptest and quickcheck to generate random inputs and verify
//! that the filter maintains its invariants under all conditions.

use diff_gitignore_filter::Filter;
use proptest::prelude::*;
use quickcheck::{quickcheck, TestResult};
use std::io::Cursor;

mod common;
use common::test_utilities::AdvancedTestRepo;

/// Generate arbitrary diff content for property testing
fn arb_diff_content() -> impl Strategy<Value = String> {
    prop::collection::vec(arb_file_diff(), 0..50).prop_map(|diffs| diffs.join("\n"))
}

/// Generate arbitrary file diff
fn arb_file_diff() -> impl Strategy<Value = String> {
    (
        arb_filename(),
        prop::collection::vec(any::<u8>(), 0..1000),
        prop::collection::vec(any::<u8>(), 0..1000),
    ).prop_map(|(filename, old_content, new_content)| {
        format!(
            "diff --git a/{} b/{}\nindex {:07x}..{:07x} 100644\n--- a/{}\n+++ b/{}\n@@ -1,{} +1,{} @@\n{}\n{}",
            filename, filename,
            old_content.len(),
            new_content.len(),
            filename, filename,
            old_content.len(), new_content.len(),
            String::from_utf8_lossy(&old_content),
            String::from_utf8_lossy(&new_content)
        )
    })
}

/// Generate arbitrary filename
fn arb_filename() -> impl Strategy<Value = String> {
    prop::collection::vec(
        prop_oneof![
            prop::char::range('a', 'z'),
            prop::char::range('A', 'Z'),
            prop::char::range('0', '9'),
            Just('.'),
            Just('_'),
            Just('-'),
            Just('/'),
        ],
        1..100,
    )
    .prop_map(|chars| chars.into_iter().collect::<String>())
}

/// Generate arbitrary .gitignore patterns
fn arb_gitignore_patterns() -> impl Strategy<Value = String> {
    prop::collection::vec(arb_gitignore_pattern(), 0..20).prop_map(|patterns| patterns.join("\n"))
}

/// Generate single .gitignore pattern
fn arb_gitignore_pattern() -> impl Strategy<Value = String> {
    prop_oneof![
        // Simple glob patterns
        "\\*\\.[a-z]{1,4}".prop_map(|s| s.replace("\\", "")),
        // Directory patterns
        "[a-z]{1,10}/".prop_map(|s| s.replace("\\", "")),
        // Negation patterns
        "![a-z]{1,10}\\.[a-z]{1,4}".prop_map(|s| s.replace("\\", "")),
        // Path patterns
        "[a-z]{1,10}/\\*\\.[a-z]{1,4}".prop_map(|s| s.replace("\\", "")),
        // Comments
        Just("# This is a comment".to_string()),
        // Empty lines
        Just("".to_string()),
    ]
}

proptest! {
    /// **What is tested:** Property that filter output is always valid UTF-8 regardless of input
    /// **Why it is tested:** Ensures the filter handles arbitrary input gracefully without producing invalid UTF-8
    /// **Test conditions:** Random gitignore patterns and diff content generated by proptest
    /// **Expectations:** Either processing succeeds with valid UTF-8 output or fails gracefully
    #[test]
    fn prop_output_is_valid_utf8(
        gitignore in arb_gitignore_patterns(),
        diff_content in arb_diff_content()
    ) {
        let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore).build().expect("Failed to create test repo").into_temp_dir();
        if let Ok(filter) = Filter::new(temp_dir.path()) {
            let mut output = Vec::new();
            let result = filter.process_diff(Cursor::new(&diff_content), &mut output);

            // Either processing succeeds and output is valid UTF-8, or it fails gracefully
            match result {
                Ok(_) => {
                    prop_assert!(String::from_utf8(output).is_ok());
                }
                Err(_) => {
                    // Errors are acceptable for malformed input
                }
            }
        }
    }

    /// **What is tested:** Property that filter produces deterministic output for identical inputs
    /// **Why it is tested:** Ensures consistent behavior and reproducible results across multiple runs
    /// **Test conditions:** Same gitignore patterns and diff content processed twice
    /// **Expectations:** Both runs should succeed/fail identically and produce identical output
    #[test]
    fn prop_deterministic_output(
        gitignore in arb_gitignore_patterns(),
        diff_content in arb_diff_content()
    ) {
        let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore).build().expect("Failed to create test repo").into_temp_dir();
        if let Ok(filter) = Filter::new(temp_dir.path()) {
            let mut output1 = Vec::new();
            let mut output2 = Vec::new();

            let result1 = filter.process_diff(Cursor::new(&diff_content), &mut output1);
            let result2 = filter.process_diff(Cursor::new(&diff_content), &mut output2);

            // Both should succeed or both should fail
            prop_assert_eq!(result1.is_ok(), result2.is_ok());

            if result1.is_ok() {
                prop_assert_eq!(output1, output2);
            }
        }
    }

    /// **What is tested:** Property that output size remains bounded relative to input size
    /// **Why it is tested:** Prevents memory exhaustion and ensures reasonable resource usage
    /// **Test conditions:** Random gitignore patterns and diff content, output size measurement
    /// **Expectations:** Output size should not exceed input size by more than 10% overhead
    #[test]
    fn prop_output_size_bounded(
        gitignore in arb_gitignore_patterns(),
        diff_content in arb_diff_content()
    ) {
        let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore).build().expect("Failed to create test repo").into_temp_dir();
        if let Ok(filter) = Filter::new(temp_dir.path()) {
            let mut output = Vec::new();
            if filter.process_diff(Cursor::new(&diff_content), &mut output).is_ok() {
                // Output should not be significantly larger than input
                // Allow 10% overhead for diff processing
                let max_expected_size = (diff_content.len() as f64 * 1.1) as usize;
                prop_assert!(output.len() <= max_expected_size);
            }
        }
    }

    /// **What is tested:** Property that empty input consistently produces empty output
    /// **Why it is tested:** Ensures correct handling of edge case with no input data
    /// **Test conditions:** Random gitignore patterns with empty string input
    /// **Expectations:** Should always produce empty output for empty input
    #[test]
    fn prop_empty_input_empty_output(gitignore in arb_gitignore_patterns()) {
        let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore).build().expect("Failed to create test repo").into_temp_dir();
        if let Ok(filter) = Filter::new(temp_dir.path()) {
            let mut output = Vec::new();
            if filter.process_diff(Cursor::new(""), &mut output).is_ok() {
                prop_assert!(output.is_empty());
            }
        }
    }

    /// **What is tested:** Property that non-diff content passes through the filter unchanged
    /// **Why it is tested:** Ensures the filter only processes actual diff content and preserves other text
    /// **Test conditions:** Random gitignore patterns and arbitrary text content (excluding diff-like content)
    /// **Expectations:** Non-diff content should pass through unchanged or with minor formatting differences
    #[test]
    fn prop_non_diff_passthrough(
        gitignore in arb_gitignore_patterns(),
        content in ".*"
    ) {
        // Skip content that looks like diff headers to avoid false positives
        if content.contains("diff --git") || content.contains("index ") {
            return Ok(());
        }

        let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore).build().expect("Failed to create test repo").into_temp_dir();
        if let Ok(filter) = Filter::new(temp_dir.path()) {
            let mut output = Vec::new();
            if filter.process_diff(Cursor::new(&content), &mut output).is_ok() {
                let output_str = String::from_utf8_lossy(&output);
                // Allow for minor formatting differences (like trailing newlines)
                prop_assert!(output_str.trim() == content.trim() || output_str == content);
            }
        }
    }
}

/// QuickCheck property: Filter creation should handle any valid .gitignore content
fn prop_filter_creation_robust(gitignore_patterns: Vec<String>) -> TestResult {
    let gitignore_content = gitignore_patterns.join("\n");
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo(&gitignore_content)
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();

    match Filter::new(temp_dir.path()) {
        Ok(_) => TestResult::passed(),
        Err(_) => {
            // Some patterns might be invalid, which is acceptable
            TestResult::discard()
        }
    }
}

/// QuickCheck property: Processing should handle malformed diff input gracefully
fn prop_malformed_diff_handling(diff_lines: Vec<String>) -> TestResult {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n*.tmp\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = match Filter::new(temp_dir.path()) {
        Ok(f) => f,
        Err(_) => return TestResult::discard(),
    };

    let diff_content = diff_lines.join("\n");
    let mut output = Vec::new();

    // Should not panic, regardless of input
    match filter.process_diff(Cursor::new(&diff_content), &mut output) {
        Ok(_) => TestResult::passed(),
        Err(_) => TestResult::passed(), // Errors are acceptable for malformed input
    }
}

/// QuickCheck property: Filter should preserve diff structure for non-ignored files
fn prop_diff_structure_preservation(filename: String, content_lines: Vec<String>) -> TestResult {
    // Skip invalid filenames (empty, whitespace-only, or containing problematic characters)
    let trimmed_filename = filename.trim();
    if trimmed_filename.is_empty()
        || trimmed_filename.contains('\n')
        || trimmed_filename.contains('\r')
        || trimmed_filename.contains('\0')
    {
        return TestResult::discard();
    }

    // Skip filenames that would be ignored by our test .gitignore
    if trimmed_filename.ends_with(".log")
        || trimmed_filename.ends_with(".tmp")
        || trimmed_filename.starts_with("target/")
    {
        return TestResult::discard();
    }

    // Create a valid diff with sanitized filename
    let diff_content = format!(
        "diff --git a/{} b/{}\nindex 1234567..abcdefg 100644\n--- a/{}\n+++ b/{}\n@@ -1,{} +1,{} @@\n{}",
        trimmed_filename, trimmed_filename, trimmed_filename, trimmed_filename,
        content_lines.len(), content_lines.len() + 1,
        content_lines.join("\n")
    );

    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n*.tmp\ntarget/\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = match Filter::new(temp_dir.path()) {
        Ok(f) => f,
        Err(_) => return TestResult::discard(),
    };

    let mut output = Vec::new();
    match filter.process_diff(Cursor::new(&diff_content), &mut output) {
        Ok(_) => {
            let output_str = String::from_utf8_lossy(&output);
            // Should contain the filename since it's not ignored
            TestResult::from_bool(output_str.contains(trimmed_filename))
        }
        Err(_) => TestResult::discard(),
    }
}

/// **What is tested:** QuickCheck property for robust filter creation with arbitrary gitignore patterns
/// **Why it is tested:** Ensures filter creation handles any valid gitignore content without crashing
/// **Test conditions:** Arbitrary gitignore pattern combinations generated by QuickCheck
/// **Expectations:** Should either create filter successfully or fail gracefully for invalid patterns
#[test]
fn quickcheck_filter_creation() {
    quickcheck(prop_filter_creation_robust as fn(Vec<String>) -> TestResult);
}

/// **What is tested:** QuickCheck property for graceful handling of malformed diff input
/// **Why it is tested:** Ensures the filter doesn't panic or crash when receiving invalid diff data
/// **Test conditions:** Arbitrary combinations of diff lines that may not form valid diff format
/// **Expectations:** Should handle malformed input without panicking, either succeeding or failing gracefully
#[test]
fn quickcheck_malformed_diff() {
    quickcheck(prop_malformed_diff_handling as fn(Vec<String>) -> TestResult);
}

/// **What is tested:** QuickCheck property for diff structure preservation with non-ignored files
/// **Why it is tested:** Ensures the filter preserves diff structure for files that should pass through
/// **Test conditions:** Arbitrary filenames and content that don't match ignore patterns
/// **Expectations:** Should preserve diff structure and include non-ignored files in output
#[test]
fn quickcheck_diff_structure() {
    quickcheck(prop_diff_structure_preservation as fn(String, Vec<String>) -> TestResult);
}

/// **What is tested:** Handling of very large files (1MB+ content) in diff processing
/// **Why it is tested:** Ensures the filter can handle large files without memory issues or performance problems
/// **Test conditions:** Diff containing 1MB of content in a single file
/// **Expectations:** Should process large files successfully without errors or excessive memory usage
#[test]
fn test_very_large_files() {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    // Create a diff with a very large file (1MB of content)
    let large_content = "x".repeat(1_000_000);
    let diff_content = format!(
        "diff --git a/large_file.txt b/large_file.txt\n\
         index 1234567..abcdefg 100644\n\
         --- a/large_file.txt\n\
         +++ b/large_file.txt\n\
         @@ -1 +1,2 @@\n\
         {large_content}\n\
         +additional line"
    );

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(&diff_content), &mut output);

    assert!(result.is_ok(), "Should handle large files without error");
    assert!(
        !output.is_empty(),
        "Should produce output for non-ignored large file"
    );
}

/// **What is tested:** Processing of diff content containing binary data (non-UTF8 bytes)
/// **Why it is tested:** Ensures the filter handles binary content gracefully without UTF-8 conversion errors
/// **Test conditions:** Diff with binary content including non-UTF8 byte sequences
/// **Expectations:** Should handle binary content without panicking, either processing or failing gracefully
#[test]
fn test_binary_diff_content() {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    // Create diff with binary content (non-UTF8 bytes)
    let binary_content = vec![0xFF, 0xFE, 0xFD, 0x00, 0x01, 0x02];
    let diff_header = "diff --git a/binary_file.bin b/binary_file.bin\n\
                      index 1234567..abcdefg 100644\n\
                      --- a/binary_file.bin\n\
                      +++ b/binary_file.bin\n\
                      @@ -1 +1,2 @@\n";

    let mut full_diff = diff_header.as_bytes().to_vec();
    full_diff.extend_from_slice(&binary_content);
    full_diff.extend_from_slice(b"\n+additional binary data\n");

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(&full_diff), &mut output);

    // Binary content might cause errors, which is acceptable
    assert!(
        result.is_ok() || result.is_err(),
        "Should handle binary content without panicking"
    );
}

/// **What is tested:** Handling of extremely long filenames (1000+ characters) in diff processing
/// **Why it is tested:** Ensures the filter handles edge cases with very long paths without buffer issues
/// **Test conditions:** Diff with filename containing 1000 characters
/// **Expectations:** Should process extremely long filenames without errors or buffer overflows
#[test]
fn test_extremely_long_filenames() {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    // Create a filename that's 1000 characters long
    let long_filename = "a".repeat(1000) + ".txt";
    let diff_content = format!(
        "diff --git a/{long_filename} b/{long_filename}\n\
         index 1234567..abcdefg 100644\n\
         --- a/{long_filename}\n\
         +++ b/{long_filename}\n\
         @@ -1 +1,2 @@\n\
         content\n\
         +more content"
    );

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(&diff_content), &mut output);

    assert!(result.is_ok(), "Should handle extremely long filenames");
}

/// **What is tested:** Processing of filenames containing Unicode characters (Chinese, emoji, Cyrillic)
/// **Why it is tested:** Ensures proper Unicode support in filename handling and pattern matching
/// **Test conditions:** Diff with filename containing various Unicode characters
/// **Expectations:** Should correctly process and preserve Unicode filenames in output
#[test]
fn test_unicode_filenames() {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    let unicode_filename = "测试文件_🦀_файл.txt";
    let diff_content = format!(
        "diff --git a/{unicode_filename} b/{unicode_filename}\n\
         index 1234567..abcdefg 100644\n\
         --- a/{unicode_filename}\n\
         +++ b/{unicode_filename}\n\
         @@ -1 +1,2 @@\n\
         content\n\
         +more content"
    );

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(&diff_content), &mut output);

    assert!(result.is_ok(), "Should handle Unicode filenames");
    let output_str = String::from_utf8_lossy(&output);
    assert!(
        output_str.contains(unicode_filename),
        "Should preserve Unicode filenames"
    );
}

/// **What is tested:** Complex nested gitignore patterns including negation and path-specific rules
/// **Why it is tested:** Ensures advanced gitignore features work correctly with complex pattern combinations
/// **Test conditions:** Complex gitignore with negation (!important.log), path patterns, and nested rules
/// **Expectations:** Should correctly apply complex pattern logic including negation and path-specific matching
#[test]
fn test_nested_gitignore_patterns() {
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo(
        "# Complex nested patterns\n\
         *.log\n\
         !important.log\n\
         /build/\n\
         docs/*.pdf\n\
         **/temp/\n\
         src/**/generated/\n",
    )
    .build()
    .expect("Failed to create test repo")
    .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    let complex_diff = "diff --git a/debug.log b/debug.log\n\
                      content\n\
                      diff --git a/important.log b/important.log\n\
                      content\n\
                      diff --git a/build/output b/build/output\n\
                      content\n\
                      diff --git a/docs/manual.pdf b/docs/manual.pdf\n\
                      content\n\
                      diff --git a/project/temp/cache b/project/temp/cache\n\
                      content\n\
                      diff --git a/src/module/generated/code.rs b/src/module/generated/code.rs\n\
                      content\n\
                      diff --git a/src/main.rs b/src/main.rs\n\
                      content\n";

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(complex_diff), &mut output);

    assert!(result.is_ok(), "Should handle complex nested patterns");
    let output_str = String::from_utf8_lossy(&output);

    // Should include important.log (negation pattern) and src/main.rs
    assert!(
        output_str.contains("important.log"),
        "Should include negated pattern"
    );
    assert!(
        output_str.contains("src/main.rs"),
        "Should include non-ignored files"
    );

    // Should exclude others based on patterns
    assert!(!output_str.contains("debug.log"), "Should exclude *.log");
    assert!(
        !output_str.contains("build/output"),
        "Should exclude /build/"
    );
    assert!(
        !output_str.contains("docs/manual.pdf"),
        "Should exclude docs/*.pdf"
    );
}

/// **What is tested:** Processing of very long gitignore patterns from fixture file
/// **Why it is tested:** Ensures the filter handles extremely long patterns without performance issues or crashes
/// **Test conditions:** Very long gitignore pattern from fixture file, diff with matching path structure
/// **Expectations:** Should process very long patterns without errors and produce reasonable output
#[test]
fn test_very_long_pattern_handling() {
    // Test with the very long pattern fixture
    let very_long_gitignore = include_str!("fixtures/very_long_pattern_gitignore.txt");
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo(very_long_gitignore)
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    // Create a diff that would match part of the very long pattern
    let diff_content = "diff --git a/very/long/path/that/goes/on/for/a/while/test.txt b/very/long/path/that/goes/on/for/a/while/test.txt\n\
                      index 1234567..abcdefg 100644\n\
                      --- a/very/long/path/that/goes/on/for/a/while/test.txt\n\
                      +++ b/very/long/path/that/goes/on/for/a/while/test.txt\n\
                      @@ -1 +1,2 @@\n\
                      content\n\
                      +more content\n";

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(diff_content), &mut output);

    assert!(
        result.is_ok(),
        "Should handle very long patterns without error"
    );

    // The file might or might not be ignored depending on the exact pattern matching
    // The important thing is that it doesn't crash
    let output_str = String::from_utf8_lossy(&output);
    // Just verify that we get some kind of reasonable output
    assert!(
        output_str.len() <= diff_content.len() * 2,
        "Output should be reasonable size"
    );
}

/// **What is tested:** Buffer limits and memory safety with extremely long filenames (10000+ characters)
/// **Why it is tested:** Ensures the filter doesn't have buffer overflow vulnerabilities with extreme input
/// **Test conditions:** Diff with filename containing 10000 characters
/// **Expectations:** Should handle extremely long filenames gracefully without buffer overflows or crashes
#[test]
fn test_pattern_buffer_limits() {
    // Test that extremely long patterns don't cause buffer overflows
    let temp_dir = AdvancedTestRepo::custom_gitignore_repo("*.log\n")
        .build()
        .expect("Failed to create test repo")
        .into_temp_dir();
    let filter = Filter::new(temp_dir.path()).expect("Failed to create filter");

    // Create a diff with an extremely long filename
    let long_filename = "a".repeat(10000) + ".txt";
    let diff_content = format!(
        "diff --git a/{long_filename} b/{long_filename}\n\
         index 1234567..abcdefg 100644\n\
         --- a/{long_filename}\n\
         +++ b/{long_filename}\n\
         @@ -1 +1,2 @@\n\
         content\n\
         +more content\n"
    );

    let mut output = Vec::new();
    let result = filter.process_diff(Cursor::new(&diff_content), &mut output);

    assert!(
        result.is_ok(),
        "Should handle extremely long filenames gracefully"
    );
}
